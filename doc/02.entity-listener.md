## EntityListener

> 잠시 시간이 부족해서 문서화가 덜 된 버전을 푸시해둡니다. 추후 깔끔하게 정리 예정입니다.

엔티티 리스너는 이벤트를 관찰하고 있다가 JPA 이벤트 발생시 특정 동작 수행합니다.<br/>

JPA 에서 제공하는 이벤트는 아래의 7가지 가 있습니다.
- @PrePersist : persist 메서드가 실행되기 전
- @PostPersist: persist 메서드가 실행된 후

- @PreUpdate : merge 메서드가 호출되기 전
- @PostUpdate : merge 메서드가 호출된 후

- @PreRemove : delete 메서드 호출되기 전
- @PostRemove : delete 메서드 호출된 후

- @PostLoad : select 메서드가 호출된 직후

<br/>

현업에서 많이 사용되는 기능은 아래와 같습니다.
- `@PrePersist`, `@PreUpdate`
- `@PostPersist`, `@PostUpdate`


이번 문서에서는 JPA 쪽에서는 굉장히 많이 알려진 BaseEntity 를 생성하는 예제를 알아봅니다. 다만 이 예제를 알아보기 전에 EntityListener 가 어떤 경우에 필요한지에 대해 알아보기 때문에 BaseEntity 에 대해서만 궁금하다면 이 글의 하단부를 확인하시면 됩니다.
<br/>



## e.g. `@PrePersist`, `@PreUpdate`

User 엔티티가 저장되기 전에 시간 데이터를 저장하려 하는 경우를 살펴보겠습니다.

```java
@Entity
public class User{
    // ...
    @PrePersist
    public void prePersist(){
        this.createdAt = LocalDateTime.now();
        this.updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    public void preUpdate(){
        this.updatedAt = LocalDateTime.now();
    }
    // ...
}
```





```java
@SpringBootTest
public class SomeTest{
    // ...

    @Test
    public void prePersistTest(){
        User user = userRepository.findById(1L).orElseThrow(RuntimeException::new);

        System.out.println("before save : " + user);
        // data.sql 에 입력해둔 1,2,3,4 id 를 가진 데이터 중 id=1 인 user 가 조회된다.
        // data.sql 에서는 createdAt, updatedAt 에 now() 를 sql 로 직접 입력해두었기에 조회시에 createdAt, updatedAt 은 null 이 아닌 상태다.

        user.setName("martin22");
        userRepository.save(user);

        System.out.println("after save : " + userRepository.findAll().get(0));
        // 출력결과를 보면 updatedAt 이 @PreUpdate 에 대해 지정한 메서드에 의해 정상적으로 지정되었음을 확인 가능하다.
    }

}
```

<br/>



## e.g. 커스텀 EntityListener 구현

@PrePersist, @PreUpdate 를 모두 Entity 마다 구현해주기에는 보일러 플레이트 코드가 많아지며, 일관적인 Rule 을 적용하려 할 경우에는 별도의 리스너 클래스로 분리하는 것이 오히려 더 장점이 될 수 있습니다.<br/>

아래 예제는 User, Book 엔티티에 대해 모두 MyEntityListener 에 의해 @PrePersist, @PreUpdate 등과 같은 엔티티 리스너들이 호출되도록 하는 설정입니다. <br/>

만약 UserHistory 에 대해서 조금은 다른 별도의 처리가 필요하다면 UserHistoryEntityListener 를 정의하는 등의 작업을 별도로 해주면 됩니다. 여기에 대해서는 뒤에서 조금 더 다른 방식의 예제로 정리합니다.<br/>

MyEntityListener.java

```java
import java.time.LocalDateTime;
import javax.persistence.PrePersist;
import javax.persistence.PreUpdate;

public class MyEntityListener {
    @PrePersist
    public void prePersist(Object o) {
        if (o instanceof Auditable) {
            ((Auditable) o).setCreatedAt(LocalDateTime.now());
            ((Auditable) o).setUpdatedAt(LocalDateTime.now());
        }
    }

    @PreUpdate
    public void preUpdate(Object o) {
        if (o instanceof Auditable) {
            ((Auditable) o).setUpdatedAt(LocalDateTime.now());
        }
    }
}
```

<br/>

User 엔티티
```java
// ...
@Entity
@EntityListeners(value = {MyEntityListener.class})
public class User{
    // ...

    @Column(updatable = false)
    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;

    // ...


//    @PrePersist
//    public void prePersist() {
//        this.createdAt = LocalDateTime.now();
//        this.updatedAt = LocalDateTime.now();
//    }
//
//    @PreUpdate
//    public void preUpdate() {
//        this.updatedAt = LocalDateTime.now();
//    }
}
```

<br/>

Book 엔티티

```java
// ...
@Entity
@EntityListeners(value = {MyEntityListener.class})
public class Book{
    // ...

    @Column(updatable = false)
    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;

    // ...


//    @PrePersist
//    public void prePersist() {
//        this.createdAt = LocalDateTime.now();
//        this.updatedAt = LocalDateTime.now();
//    }
//
//    @PreUpdate
//    public void preUpdate() {
//        this.updatedAt = LocalDateTime.now();
//    }
}
```

<br/>



## Auditable 인터페이스 정의

```java
// ...
public interface Auditable {
    LocalDateTime getCreatedAt();
    LocalDateTime getUpdatedAt();

    void setCreatedAt(LocalDateTime createdAt);
    void setUpdatedAt(LocalDateTime updatedAt);
}

// ...
public class MyEntityListener {
    @PrePersist
    public void prePresist(Object o){
        if(o instanceof Auditable){
            ((Auditable) o).setCreatedAt(LocalDateTime.now());
            ((Auditable) o).setUpdatedAt(LocalDateTime.now());
        }
    }

    @PreUpdate
    public void preUpdate(Object o){
        if(o instanceof Auditable){
            ((Auditable) o).setUpdatedAt(LocalDateTime.now());
        }
    }
}
```



## User 에 대한 저장을 감지하는 UserHistoryListener

User 데이터 처리시 UserHistory 테이블을 엔티티 리스너로 처리하는 케이스도 살펴보겠습니다.

History 테이블의 경우 현업에서 보통 특정 도메인의 데이터가 추가되면 그 값의 복사본을 `--History` 라는 테이블에 별도로 저장해두는 케이스가 많습니다. <br/>

User 에 대한 처리를 할 때 UserHistory 역시도 별도로 코드로 작성해서 Service 등으로 작성할 수도 있는데<br/>

이런 방식은 프로그래머가 일일이 하드코딩을 해줘야 하고 휴먼에러가 발생할 수 있다는 요소도 있습니다.<br/>

이런 요소를 방지하기 위해 이번 예제에서는 User 데이터 저장/수정 발생시 UserHistory 에 대한 별도의 코드를 작성하지 않아도 엔티티 리스너에서 감지해서 UserHistory 에 대한 처리 역시도 수행할 수 있도록 엔티티 리스너로 처리하도록 하는 예제를 작성합니다.<br/>

(아래의 UserEntityListener 참고)

```java
@Entity
@EntityListeners(value = {MyEntityListener.class, UserEntityListener.class})
public class User {
    // ...
}

@Entity
@EntityListeners(value = MyEntityListener.class)
public class UserHistory implements Auditable{
    @Id
    @GeneratedValue
    private Long id;

    private Long userId;

    private String name;

    private String email;

    private LocalDateTime createdAt;

    private LocalDateTime updatedAt;
}

public interface UserHistoryRepository extends JpaRepository<UserHistory, Long>{
}


public class UserEntityListener {
    @PrePersist
    @PreUpdate
    public void prePersistAndPreUpdate(Object o) {
        // BeanUtils 는 아래에서 따로 정의함
        UserHistoryRepository userHistoryRepository = BeanUtils.getBean(UserHistoryRepository.class);

        User user = (User) o;

        UserHistory userHistory = new UserHistory();
        userHistory.setUserId(user.getId());
        userHistory.setName(user.getName());
        userHistory.setEmail(user.getEmail());

        userHistoryRepository.save(userHistory);
    }
}

// support 패키지 생성
// 스프링 빈을 로딩해오는 클래스 생성
@Component
public class BeanUtils implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        BeanUtils.applicationContext = applicationContext;
    }

    public static <T> T getBean(Class<T> clazz) {
        return applicationContext.getBean(clazz);
    }
}

class UserRepositoryTest {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private UserHistoryRepository userHistoryRepository;

    // ...

    @Test
    void userHistoryTest() {
        User user = new User();
        user.setEmail("martin-new@fastcampus.com");
        user.setName("martin-new");

        userRepository.save(user);

        user.setName("martin-new-new");

        userRepository.save(user);

        userHistoryRepository.findAll().forEach(System.out::println);
    }

    // ...

}
```

<br/>



## Spring 의 AuditingEntityListener

지금까지는 createdAt, updatedAt 을 @PrePersist, @PreUpdate 등을 EntityListener라는 별도의 클래스 등으로 분리한 후 어떻게 재활용이 높은 코드로 발전시킬 수 있는지를 살펴봤습니다.<br/>

그런데 createdAt, updatedAt 은 자주 사용되는 정보이기에 Spring Framework 에서도 이 부분에 대해 별도의 기능을 제공하고 있다. 스프링은 별도의 기본 리스너를 제공하고 있습니다.<br/>

먼저 `@EnableJpaAuditing` 을 Configuration 클래스 또는 `@SpringBootApplication` 이 위치한 클래스에 추가해줍니다.

```java
@SpringBootApplication
@EnableJpaAuditing
public class JpaStudyApplication{
    // ...
    public static void main(String [] args){
        SpringApplication.run(JpaStudyApplication.class, args);
    }
}
```

<br/>



```java
@Entity
// @EntityListeners(value = {MyEntityListener.class, UserEntityListener.class})
@EntityListeners(value = {AuditingEntityListener.class, UserEntityListener.class})
// ...
public class User {
    // ...
    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;
}


@Entity
// @EntityListeners(value = {MyEntityListener.class, UserEntityListener.class})
@EntityListeners(value = AuditingEntityListener.class)
// ...
public class UserHistory implements Auditable {
    // ...
    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;
}


@Entity
// @EntityListeners(value = {MyEntityListener.class})
@EntityListeners(value = AuditingEntityListener.class)
// ... 
public class Book implements Auditable {
    // ...
    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;
}
```

스프링에서는 이외에도 @CreatedBy, @LastModifiedBy 등과 같은 어노테이션 등을 제공하고 있습니다.<br/>

이 스프링에서 제공하는 것 외의 다른 기능이 필요하다면 위에서 직접 작성했던 MyEntityListener 와 UserEntityListener 를 적절히 잘 활용하면 새로운 엔티티 리스너를 정의해서 실무에 필요한 엔티티 리스너를 정의하는 것 역시 가능합니다.<br/>



## @MappedSuperClass 를 이용해서 별도의 클래스에 엔티티 리스너 필드 공통화작업

지금까지는 엔티티 리스너를 왜 사용하는지에 대한 과정을 설명했다면, 이번에는 실제 현업에서 많이 사용하는 방식을 설명해봅니.

```java
@Data
@MappedSuperClass
@EntityListeners(value = AuditingEntityListener.class)
public class BaseEntity {
    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;
}
```

BaseEntity 를 선언했다. 그리고 `@MappedSuperClass` 를 사용했습니다. 

`@MappedSuperClass` 어노테이션은 `@MappedSuperClass` 가 붙은 클래스의 자식 클래스들은 `@MappedSuperClass` 가 붙은 클래스의 필드들을 모두 상속받아서 사용할 수 있도록 해주는 어노테이션입니다. 

이제 BaseEntity 를 상속받는 자식 클래스들을 정의합니.

```java
@Entity
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
// @EntityListeners(value = {AuditingEntityListener.class, UserEntityListener.class})
// UserEntityListener 는 UserHistory 처리를 해야 하므로 필요
@EntityListeners(value = {UserEntityListener.class}) 
// public class User implements Auditable {
public class User extends BaseEntity implements Auditable { // extends BaseEntity 추가 
    // ...

//    @CreatedDate
//    private LocalDateTime createdAt;

//    @LastModifiedDate
//    private LocalDateTime updatedAt;

    // ...

}


@Entity
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
// @EntityListeners(value = AuditingEntityListener.class)
// ...
// public class UserHistory implements Auditable {
public class UserHistory extends BaseEntity implements Auditable { // extends BaseEntity 추가 
    // ...
    @CreatedDate
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;
}


@Entity
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
// @EntityListeners(value = AuditingEntityListener.class)
// ...
// public class Book implements Auditable {
public class Book extends BaseEntity implements Auditable { // extends BaseEntity 추가 
    // ...
}
```

<br/>

디버깅 시에 아래 내용을 User, UserHistory, Book 각각 추가하면, BaseEntity 의 필드들을 로그로 찍어볼 수 있습니다.

```java
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
// ...
```

<br/>



## Auditable 을 BaseEntity 에서 implements 하는 방식으로 변경

각각의 엔티티 클래스마다 일일이 implements Auditable 을 해두는 것 보다 BaseEntity 에서만 Auditable 을 implements 하는 것이 오히려 더 나을 수 있습니다. <br/>

BaseEntity 클래스를 아래와 같이 수정해줍니다.

```java
@MappedSuperclass
@EntityListeners(value = AuditingEntityListener.class)
// public class BaseEntity { 
public class BaseEntity implements Auditable { // (1) 
    @CreatedDate
    @Column(columnDefinition = "datetime(6) default now(6) comment '생성시간'", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(columnDefinition = "datetime(6) default now(6) comment '수정시간'", nullable = false)
    private LocalDateTime updatedAt;
}
```

(1)

\- Auditable 을 implements 하도록 변경해줬다.

<br/>



Book, User, UserHistory 엔티티 모두 `implements Auditable` 을 제거해준다.

```java
@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
//@DynamicUpdate
@Where(clause = "deleted = false")
// public class Book extends BaseEntity  implements Auditable{ // -- (1)
public class Book extends BaseEntity {
    // ... 
}


@NoArgsConstructor
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
@Builder
@Entity
@EntityListeners(value = { UserEntityListener.class })
// public class User extends BaseEntity implements Auditable{ // -- (1)
public class User extends BaseEntity {
    // ...
}


@Entity
@NoArgsConstructor
@Data
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
// public class UserHistory extends BaseEntity implements Auditable{ // -- (1)
public class UserHistory extends BaseEntity {
    // ...
}
```



(1)

\- Book, User, UserHistory 모두 `implements Auditable` 을 해줬다.

<br/>



##  @PrePersist, @PreUpdate 대신 @PostPersist, @PostUpdate 를 사용

지금까지처럼 @PrePersist, @PreUpdate 를 하면 UserHistory 를 출력할 때 User 엔티티가 DB에 저장되어 커밋된 상태가 아니라면 UserHistory 에는 userId=null 로 기록되게 된다는 단점이 있다.<br/>

따라서 UserEntityListener 에 대해서는 UserEntity 가 저장된 후에 리스너가 동작하도록 @PostPersist, @PostUpdate 를 사용하도록 코드를 변경해주어야 합니다. 

```java
public class UserEntityListener {
    @PostPersist
    @PostUpdate
    public void persistAndPreUpdate(Object o) {
        // BeanUtils 는 아래에서 따로 정의함
        UserHistoryRepository userHistoryRepository = BeanUtils.getBean(UserHistoryRepository.class);

        User user = (User) o;

        UserHistory userHistory = new UserHistory();
        userHistory.setUserId(user.getId());
        userHistory.setName(user.getName());
        userHistory.setEmail(user.getEmail());

        userHistoryRepository.save(userHistory);
    }
}
```

