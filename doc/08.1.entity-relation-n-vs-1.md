# N vs 1 연관관계

## 단방향 설계시 1vsN, Nvs1 중 어떤 것을 선택할까?
만약 단방향으로 객체 관계를 설계할 때 `@ManyToOne`, `@OneToMany` 둘 중 어떤 것이 나은지 고민하게 됩니다.<br/>

User 와 UserHistory 관계를 예로 들어보겠습니다. 

- user 테이블은 기본키만 가지고 있다.
- user\_history 테이블은 user 테이블의 id 를 외래키로 가지고 있다.

<br/>



## 연관관계의 주인과 mappedBy

- [JPA 연관관계 매핑](https://colevelup.tistory.com/41)

user 와 user\_history 테이블을 예로 들어보겠습니다. 

user 테이블은 다음과 같이 구성되어 있습니다.

| 컬럼명 | 타입         |
| ------ | ------------ |
| id     | BIGINT       |
| name   | VARCHAR(70)  |
| email  | VARCHAR(100) |

<br/>



이번에는 user\_history 테이블입니다.

| 컬럼명       | 타입     |
| ------------ | -------- |
| id           | BIGINT   |
| user_id (fk) | BIGINT   |
| created\_at  | DATETIME |

<br/>

### user 테이블 - mappedBy 

user 테이블은 마스터 테이블 같은 역할을 합니다.<br/>

user 테이블 내의 기본키는 여러가지 부가적인 정보를 가지는 user\_history, user\_role 등과 같은 여러가지 자식 테이블에서 외래키로 참조합니다.<br/>

user 테이블은 관계형 데이터베이스에서는 마스터 역할을 하지만, 객체관계에서는 mapping 을 당하게 되므로 mappedBy 라는 말로 표현됩니다. 실제로 객체 매핑시에도 mappedBy 를 통한 매핑을 하게 됩니다.<br/>



### user\_history 테이블 - 연관관계의 주인, FK 소유

테이블 관계에서는 마스터 테이블인 user 에 대한 자식테이블 같은 역할을 하지만<br/>

객체 관계에서는 user\_history 가 연관관계의 주인역할을 합니다.<br/>

연관관계의 주인은 외래키(FK) 를 가지고 있으며, 외래키(FK)를 관리(등록, 수정)할 수 있습니다.<br/>

자꾸 헷갈린다면 하나만 기억하시면 됩니다.

- 외래키(FK)를 가지고 있는 테이블이 연관관계의 주인이다.
- 연관관계의 주인 만이 외래키(FK)를 관리(등록, 수정)할 수 있다.
- 반대편 테이블은 mappedBy로 표현된다.

 <br/>



### mappedBy 를 사용하는 이유

참고: [양방향 매핑시 mappedBy가 필요한 이유](https://velog.io/@wogh126/JPA-%EC%96%91%EB%B0%A9%ED%96%A5-%EB%A7%A4%ED%95%91%EC%97%90%EC%84%9C-MappedBy%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0)

예를 들어 User, UserHistory 객체가 각각 서로 User 테이블의 데이터 값을 변경하려 할 경우 무결성이 깨질 수 있습니다. 이때 User, UserHistory 두 객체 중 하나의 객체만 테이블을 관리할 수 있도록 지정하는 옵션은 `mappedBy` 옵션입니다.<br/>



## 이번 문서에서는

이번 문서에서는 N:1 연관관계 예제들을 양방향 예제로 작성합니다.<br/>

편의상 `@Data` 를 사용했습니다. 실무에서는 꼭 `@Data` 를 사용하지 않으시기를 바랍니다.<br/>



## e.g. book (N) vs publisher (1)

publisher(출판사) 에서는 여러 책을 출판할 수 있습니다.<br/>

### Book.java

```java
// ...

@Data
@Entity
@Table(name = "book")
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor(staticName = "ofAll")
@EqualsAndHashCode(exclude = "publisher")
public class Book {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(name = "name", columnDefinition = "VARCHAR(200)")
  private String name;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "publisher_id", columnDefinition = "BIGINT")
  private Publisher publisher;
}
```

<br/>



### Publisher.java

```java
// ...

@Data
@Entity
@Table(name = "publisher")
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@EqualsAndHashCode(exclude = "publisher")
public class Publisher {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @ToString.Exclude
  @OneToMany(mappedBy = "publisher", cascade = {CascadeType.MERGE, CascadeType.PERSIST})
  private List<Book> books = new ArrayList<>();

  @Column(name = "name", columnDefinition = "VARCHAR(70)")
  private String name;
}
```

<br/>



### schema.sql

```sql
create table book
(
    id           bigint         not null    auto_increment      comment 'id',
    name         varchar(70)    not null    comment '도서명',
    publisher_id bigint         not null    comment '출판사 id',
    primary key (id)
);

create table publisher
(
    id          bigint          not null    auto_increment      comment 'id',
    name        varchar(70)     not null    comment '출판사명',
    primary key (id)
);
```

<br/>



### data.sql

```sql
insert into publisher(name) values ('아침사과');
insert into publisher(name) values ('갤리온');
insert into publisher(name) values ('열린 책들');

insert into book(name, publisher_id) values('글루코스 혁명', 1);
insert into book(name, publisher_id) values('생각 중독', 1);
insert into book(name, publisher_id) values('퀸의 대각선 1', 3);
```

<br/>



### PublisherRepository

```java
package io.summary.jpa.jpa_summary.repository;

import io.summary.jpa.jpa_summary.entity.Publisher;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface PublisherRepository extends JpaRepository<Publisher, Long> {
  @Query(
      "select p "
    + "from Publisher p "
    + "inner join fetch p.books "
    + "where p.id = :id"
  )
  Publisher findBookByIdFetch(@Param("id") Long id);
}
```

<br/>



### 테스트코드

```java
// ...

@ExtendWith(DatabaseClearExtension.class)
@ActiveProfiles({"mysql-test"})
@SpringBootTest
public class PublisherRepositoryTest {
  @Autowired
  private PublisherRepository publisherRepository;
  @Autowired
  private BookPublisherDataset bookPublisherDataset;

  private static final Logger logger = LoggerFactory.getLogger(PublisherRepositoryTest.class);

  @BeforeEach
  public void init(){
    bookPublisherDataset.fetchDataSql();
  }

  @Transactional
  @Test
  public void test__책정보와_함께_출판사정보를_조회(){
    Publisher publisher = publisherRepository.findBookDetailDtoById(1L);
    logger.info("publisher == {}", publisher.toString());
    publisher.getBooks().forEach(book -> logger.info("book.name = {}", book.getName()));
  }
}
```

<br/>



## e.g. review (N) vs book (1)

book 에는 review 가 여러개 달릴 수 있습니다.<br/>

퇴근 후 예제 코드 추가 예정<br/>



## e.g. review (N) vs user (1)

user 는 review 를 여러개 달 수 있습니다.<br/>

<br/>



## e.g. user\_history (N) vs user (1)

user 의 활동기록인 user\_history 는 여러개 기록될 수 있습니다.<br/>

<br/>

